#LyX 2.2 created this file. For more info see http://www.lyx.org/
\lyxformat 508
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\begin_preamble
\usepackage{changepage}
\date{}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "Cambria"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts true
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing other 1.2
\use_hyperref false
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 25col%
\topmargin 20col%
\rightmargin 25col%
\bottommargin 20col%
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Integration Test Plan Document
\end_layout

\begin_layout Standard
\align left
\begin_inset VSpace vfill
\end_inset


\series bold
\size large
Document Version 1.0
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset


\series default
Matteo Frosi (mat.
 875393)
\begin_inset Newline newline
\end_inset

Luca Costa (mat.
 808109)
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Subsection
Scope and purpose
\end_layout

\begin_layout Standard
The purpose of the Integration Test Plan Document (ITPD) is to present to
 the testing team the sequence of tests to be applied to different components
 and interfaces forming the application.
 The goal is to test whether the components and interfaces designed and
 proposed in the Design Document behave in the expected manner and interact
 with each other correctly or not.
 
\begin_inset Newline newline
\end_inset

Each component (interface) is overlooked by a test, that analyzes its correctnes
s and coherence.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
To add information about the ordering of test
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Definitions and abbreviations
\end_layout

\begin_layout Itemize
RASD: Requirements Analysis and Specifications Document.
\end_layout

\begin_layout Itemize
DD: Design Document.
\end_layout

\begin_layout Itemize
ITPD: Integration Test Plan Document.
\end_layout

\begin_layout Itemize
Stub: some codes emulating other functionality or data, eventually using
 fake data.
\end_layout

\begin_layout Itemize
Drivers: drivers are like stubs with the difference that they are not used
 to be called by the component actually tested, but they are used to call
 themselves specific functions of the component actually tested.
 In this document the word driver is also used to design the “driver component”
 of our application.
 The distinction between the two should easily be done by the reader thanks
 to the context.
\end_layout

\begin_layout Itemize
Mocks: stubs with the possibility of verifying whether or not a specific
 method of this mock has called a specific number of times.
 Mocks are therefore slightly more complex stubs.
 
\end_layout

\begin_layout Itemize
Unit test: the most famous way to perform tests via assertions.
\end_layout

\begin_layout Itemize
Bottom-up: Bottom-up is a strategy of information processing.
 It is used in many different fields such as software or scientific theories.
 Regarding integration testing, the bottom-up strategy consists in the integrati
on of low level modules first and the integration of higher level modules
 after.
\end_layout

\begin_layout Itemize
Top-down: Top-down is a strategy of information processing.
 Regarding integration testing, the top-down strategy consists in the integratio
n of high level modules first and the integration of lower level modules
 after.
 It is the opposite of bottom-up.
\end_layout

\begin_layout Itemize
Big-bang: Big-bang is a non-incremental integration strategy where all the
 components are integrated at once, right after they are all unit-tested.
 
\end_layout

\begin_layout Itemize
jMeter: Java GUI program to measure the performance of a web server, it
 is developed by Apache.
\end_layout

\begin_layout Itemize
Apache: open source software company.
\end_layout

\begin_layout Itemize
SMS: short message service; it is the most famous way to send text messages
 to a mobile phone.
 
\end_layout

\begin_layout Itemize
Push notification: the modern way to send complex messages to a smartphone.
\end_layout

\begin_layout Itemize
API: application programming interface; it is a common way to communicate
 with another system.
\end_layout

\begin_layout Section
Integration strategy
\end_layout

\begin_layout Subsection
Entry criteria
\end_layout

\begin_layout Standard
In this subsection there are specified the criteria that must be met before
 integration testing of specific elements can begin (e.g., functions and modules
 must have been unit tested).
\begin_inset Newline newline
\end_inset

Some classes, the ones representing the software model, must be unit-tested
 immediately, to perform then the rest of tests, such the integration ones.
 These classes includes:
\end_layout

\begin_layout Itemize
Reservation
\end_layout

\begin_layout Itemize
Monitoring
\end_layout

\begin_layout Itemize
Ride
\end_layout

\begin_layout Itemize
SafeArea
\end_layout

\begin_layout Itemize
Car
\end_layout

\begin_layout Itemize
User
\end_layout

\begin_layout Standard
Moreover, all the classes related to the controllers should be unit-tested,
 independently from the other model classes.
 As example, the ServiceCore component includes all the algorithm classes,
 two of them discussed in section 3 of the Design Document.
 
\begin_inset Newline newline
\end_inset

All the methods, with the exception of getters, should be tested.
 Referring once again to the algorithms presented in the DD as example,
 we have (with the notation # representing inside the class and -> inside
 the component):
\end_layout

\begin_layout Itemize
Car#changePosition: elaborates the new position of the car
\end_layout

\begin_layout Itemize
ServiceCore->LocationModule#isInSafeArea: checks whether a car is in a safe
 area or not
\end_layout

\begin_layout Itemize
ServiceCore->LocationModule#isMoreThan3kmDistant: checks whether a car is
 more than 3km distant from the nearest safe area
\end_layout

\begin_layout Itemize
ServiceCore->RideCostAlgorithm#calculateRideCost: invoked at the end of
 the service, it calculates the cost of a ride, given its parameters (duration,
 bonuses, and so on)
\end_layout

\begin_layout Itemize
ModelSkeleton#getMonitoringByCar: returns a Monitoring if, given the research
 car, there is one, nothing otherwise
\end_layout

\begin_layout Itemize
SafeAreas#addSafeArea: adds a safe area to the list of parking zones of
 PowerEnJoy
\end_layout

\begin_layout Standard
Obviously, the just presented methods are nothing but a fragment of all
 the parts of our software to be tested.
\end_layout

\begin_layout Subsection
Elements to be integrated
\end_layout

\begin_layout Standard
All the components described in the component view section of the Design
 Document, 2.3.2, have to be integrated.
 
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename /Users/Matteo/Desktop/Software-Engineering-II-Project/DD/StructureDiagrams/DetailedComponent.png
	lyxscale 10
	scale 13

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Components to be integrated
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

 
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
An interesting fact to point out is that mid level components, such as the
 controllers, don't need the lower components, or classed, to be fully implement
ed when tested.
 Each class forming a component needs in fact only some aspects and functionalit
y provided by the lower level modules.
 As example, the RideCostAlgorithm in the ServiceCore component doesn't
 need a Model that includes methods to research active Reservation and Monitorin
g objects, but it does need information about the Ride on which it is needed
 to calculate the cost.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Integration Testing strategy
\end_layout

\begin_layout Standard
As previously stated, more complex components, such as the controllers,
 do not require a complete version of the depending modules/classes to be
 tested.
 This lead to a possible approach, very similar to the bottom-up method
 but with a significant difference.
 While the latter starts from the 
\begin_inset Quotes eld
\end_inset

leaves
\begin_inset Quotes erd
\end_inset

 of the software, that in this case are the model classes, the possible
 approach allows to start the testing from any depth of complexity, creating
 fragment of modules and only then integrating them, completing the lower
 level module.
 There are advantages but also drawbacks.
 Such approach is very fast in the early phases, because it allows to 
\begin_inset Quotes eld
\end_inset

take care
\begin_inset Quotes erd
\end_inset

 of the trickier components of the software and simultaneously makes the
 lower components be partially built.
 However, the tests are independent one from the other and the lower modules
 that are constructed to accomplish higher component tests may be incompatible
 or, in the worst case, conflicting.
 A good idea to solve this is to group each module realization given by
 the lower dependencies, but it requires foreseeing skills and it's difficult
 to accomplish.
 Moreover such approach is an easy trap, because if the starting depth is
 the highest, we will fall in the top-down approach.
 
\begin_inset Newline newline
\end_inset

A bottom-up approach suits better the sequence of integrations that will
 have to be applied on the components of the software, for the easy location
 of errors and the not need of stubs.
 Not always lower level means simplicity, and because higher level components,
 following the bottom-up approach, would be tested lastly, a variant of
 the bottom-up method could be followed.
 Instead of growing in depth, from lower to higher, it could be followed
 the dimension growth of modules, referring to the first approach presented.
 Moving down to top, so still using a bottom-up approach, some modules can
 be partially tested or even skipped, to leave space for more important
 modules.
 The skipped/partially tested classes/modules can be completed after that.
 So, we are not moving just upwards, but in a 
\begin_inset Quotes eld
\end_inset

snakelike
\begin_inset Quotes erd
\end_inset

 way.
 Such approach also gives the chance to catch a glimpse of the higher level
 components (and tests) while testing the lower level ones.
 
\end_layout

\begin_layout Subsection
Sequence of integrations
\end_layout

\begin_layout Standard
Because we are following a bottom-up like approach (with elements of top-down),
 both drivers and stubs are requested to be created, respectively that call
 and are called by the functions to be tested.
\end_layout

\begin_layout Subsubsection
Server
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename IntegrationSequenceImages/IntegrationServer.png
	lyxscale 20
	scale 30

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Integration sequence on the server
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="9" columns="3">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="6col%">
<column alignment="left" valignment="middle" width="70col%">
<column alignment="left" valignment="top" width="14col%">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
ID
\end_layout

\end_inset
</cell>
<cell multirow="3" alignment="left" valignment="middle" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Integration Test
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Paragraph
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
IS1
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
NotificationManager -> GMSGateway, PushGateway
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3.1.1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
IS2
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ServiceCore -> Model
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3.1.2
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
IS3
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ServiceCore -> NotificationManager
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3.1.3
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
IS4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
LoginController -> Model
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3.1.4
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
IS5
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ReservationController -> Model, NotificationManger
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3.1.5
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
IS6
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
MonitoringController -> Model, NotificationManager
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3.1.6
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
IS7
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
RideController -> Model, NotificationManager
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3.1.7
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
IS8
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ConnectionHandler -> ReservationController, MonitoringController, RideController
, LoginController
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3.1.8
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
A note must be made on the integration tests with ID 4, 5, 6 and 7, referring
 to the controllers of the server.
 Even though they requires an integration with the Model component, they
 interact just with a small chunk of its modules.
 As example, the ReservationController will interact only with Car, SafeArea,
 Reservation and User, while Ride will interact with all except for the
 Monitoring and Reservation objects.
 Such consideration makes the integration test easier and less verbose,
 due to the fact that each integration requires not all the modules of a
 component.
\begin_inset Newline newline
\end_inset

Last important thing to mention is that there could also be an integration
 test between the ConnectionHandler and the Model, because of the interaction
 between the Car and the Server, but the exchanged messages are very simple,
 just a cluster of data, and such handled directly by the ConnectionHandler
 directly into the Model.
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Car
\end_layout

\begin_layout Standard
The car needs only one test for integration, assuming that both components,
 the software part of the CarSensorSystem and the CarApplication have already
 been unit tested.
 Without any need of figures describing the situation, we have:
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="3">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="6col%">
<column alignment="left" valignment="top" width="70col%">
<column alignment="left" valignment="top" width="14col%">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
ID
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Integration Test
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Paragraph
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
IC1
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
CarApplication -> CarSensorSystem (software)
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3.2.1
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsubsection
Subsystem integration sequence
\end_layout

\begin_layout Standard
The PowerEnJoy software can be divided into different high level subsystems,
 As can be seen in section 2.3.1 of the Design Document, the high level components
 are four:
\end_layout

\begin_layout Itemize
Server
\end_layout

\begin_layout Itemize
Database
\end_layout

\begin_layout Itemize
User
\end_layout

\begin_layout Itemize
Car
\end_layout

\begin_layout Standard
As it can be seen from Figure 2, in subsection 2.4.1, describing the server
 sequence of integrations to be done, the Server is composed by three big
 chunks of components:
\end_layout

\begin_layout Itemize
Communication components: NotificationManager, PushGateway, GMSGateway,
 ConnectionHandler
\end_layout

\begin_layout Itemize
Processing components: ServiceCore, ReservationController, MonitoringController,
 RideController
\end_layout

\begin_layout Itemize
Data storing components: Model and its subclasses
\end_layout

\begin_layout Standard
These three clusters can be considered as different subsystems.
 The Model needs no further test since all of its modules have already been
 unit-tested.
 There is not a complete integration step between two or more components,
 but there are multiple interactions.
 As example we can just consider the Server integration sequence described
 in 2.4.1, having the Communication, Processing and Data storing components
 interact multiple times in the integration.
 
\begin_inset Newline newline
\end_inset

Once the integration between the Server components is done, the Database
 will be integrated, followed by the Car and lastly the User.
 The User must be integrated lastly because this way it can fully make use
 of all the functionality provided by the other subsystems.
 However the integration of the Car subsystem requires a version of the
 Client, that acts as a driver, to work and to be tested.
 
\begin_inset Newline newline
\end_inset

Why the Car subsystem first and then the User and not viceversa? The Car
 subsystem moves in a stand-alone way (the periodic updates do not requires
 the intervention of the user, hence the User components) or user driven.
 The last includes a single event, from the user, that leads, in a waterfall
 way, to the Car subsystem usage.
 It is then very easy to 
\begin_inset Quotes eld
\end_inset

stimulate
\begin_inset Quotes erd
\end_inset

, and then test, the Car before the User just by emulating such events (as
 a simple Reservation or PickUp).
\begin_inset Newline newline
\end_inset

In the following figure, representing what has been just said, the arrows
 direction mean 
\begin_inset Quotes eld
\end_inset

What has to be integrated with what
\begin_inset Quotes erd
\end_inset

.
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename IntegrationSequenceImages/SubsystemIntegration.png
	lyxscale 40
	scale 40

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Subsystem integration
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="8" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top">
<column alignment="left" valignment="top" width="70col%">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
ID
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Integration Test
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SS1
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Processing components -> Model
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SS2
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Processing components <-> Communication components
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SS3
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Model -> Communication components
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\shape italic
\color blue
SS123
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\shape italic
\color blue
At this point the Server is fully integrated internally
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SS4
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Database -> Server
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SS5
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Car -> Server
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SS6
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
User -> Server
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Individual steps and Test description
\end_layout

\begin_layout Subsection
Server integration test cases
\end_layout

\begin_layout Subsubsection
Test case IS1
\end_layout

\begin_layout Itemize

\series bold
ID:
\series default
 IS1T1.
\end_layout

\begin_layout Itemize

\series bold
Test Item(s):
\series default
 NotificationManager -> GMSGateway.
\end_layout

\begin_layout Itemize

\series bold
Input specification:
\series default
 User (from the Model).
\end_layout

\begin_layout Itemize

\series bold
Output specification:
\series default
 a notification is sent as a mail or an SMS to the GMS gateway.
\end_layout

\begin_layout Itemize

\series bold
Description/purpose:
\series default
 when the user creates an account or requests the access code for the car
 he/she has to be correctly notified via SMS or mail.
 This is possible verifying the interaction between the NotificationManager
 and GMSGateway components.
\end_layout

\begin_layout Itemize

\series bold
Dependencies:
\series default
 GMSGateway stub.
\end_layout

\begin_layout Standard
\align center
\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "60col%"
height "1pt"

\end_inset


\end_layout

\begin_layout Itemize

\series bold
ID:
\series default
 IS1T2.
\end_layout

\begin_layout Itemize

\series bold
Test Item(s):
\series default
 NotificationManager -> PushGateway.
\end_layout

\begin_layout Itemize

\series bold
Input specification:
\series default
 User (from the Model).
\end_layout

\begin_layout Itemize

\series bold
Output specification:
\series default
 a push notification to the GMS gateway.
\end_layout

\begin_layout Itemize

\series bold
Description/purpose:
\series default
 when the user creates succeeds in creating a reservation or a monitoring
 or when it receives the ride end data he/she has to be correctly notified.
 This is possible verifying the interaction between the NotificationManager
 and PushGateway components.
\end_layout

\begin_layout Itemize

\series bold
Dependencies:
\series default
 PushGateway stub.
\end_layout

\begin_layout Subsubsection
Test case IS2
\end_layout

\begin_layout Itemize

\series bold
ID:
\series default
 IS2T1.
\end_layout

\begin_layout Itemize

\series bold
Test Item(s):
\series default
 ServiceCore -> Model.
\end_layout

\begin_layout Itemize

\series bold
Input specification:
\series default
 ServiceCore modules (algorithm classes), Monitoring, Reservation, Car,
 User, Ride, SafeArea.
\end_layout

\begin_layout Itemize

\series bold
Output specification:
\series default
 all the algorithms are executed in the correct way.
\end_layout

\begin_layout Itemize

\series bold
Description/purpose:
\series default
 while the Model contains only a skeleton, a copy of the software data,
 the ServiceCore components contain all the necessary modules to compute
 and process the data.
 All the connections between the ServiceCore and the Model have to be tested.
\end_layout

\begin_layout Itemize

\series bold
Dependencies:
\series default
 NONE.
\end_layout

\begin_layout Subsubsection
Test case IS3
\end_layout

\begin_layout Itemize

\series bold
ID:
\series default
 IS3T1.
\end_layout

\begin_layout Itemize

\series bold
Test Item(s):
\series default
 ServiceCore -> NotificationManager
\end_layout

\begin_layout Itemize

\series bold
Input specification:
\series default
 Model modules.
\end_layout

\begin_layout Itemize

\series bold
Output specification:
\series default
 a notification (push or message) is sent to the User.
\end_layout

\begin_layout Itemize

\series bold
Description/purpose:
\series default
 whenever an event occurs, such as a successful end of the service or just
 a registration, the User has to be notified.
 It may seem strange that this happens at the ServiceCore level and not
 for each respective controller, but the controllers only has the task to
 elaborate the incoming information and instruct the Model (and ServiceCore)
 on what to do.
 The real logic can be found in the ServiceCore, hence the end of an event
 chain triggers the notification for the User.
\end_layout

\begin_layout Itemize

\series bold
Dependencies:
\series default
 GMSGateway and PushGateway stub.
\end_layout

\begin_layout Subsubsection
Test case IS4
\end_layout

\begin_layout Itemize

\series bold
ID:
\series default
 IS4T1.
\end_layout

\begin_layout Itemize

\series bold
Test Item(s):
\series default
 LoginController -> Model.
\end_layout

\begin_layout Itemize

\series bold
Input specification:
\series default
 User (from Model).
\end_layout

\begin_layout Itemize

\series bold
Output specification:
\series default
 an existing User in the Model changes status in successfully logged in
 or logged out as a consequence of a trigger message or an expiration of
 a timer.
\end_layout

\begin_layout Itemize

\series bold
Description/purpose:
\series default
 the correct interaction between the LoginController and the model has to
 be verified, since it represents one of the most important phase.
 An incorrect interaction may lead to wrong usage of the service and it
 can even be exploited to damage it.
 Hence, this is a critical test, that must be done before the other controllers
 are integrated (as example a not logged user mustn't make a reservation
 or a monitoring request.
\end_layout

\begin_layout Itemize

\series bold
Dependencies:
\series default
 Database stub.
\end_layout

\begin_layout Subsubsection
Test case IS5
\end_layout

\begin_layout Itemize

\series bold
ID:
\series default
 IS5T1.
\end_layout

\begin_layout Itemize

\series bold
Test Item(s):
\series default
 ReservationController -> Model.
\end_layout

\begin_layout Itemize

\series bold
Input specification:
\series default
 ReservationController modules, Reservation, Car, User (from Model).
\end_layout

\begin_layout Itemize

\series bold
Output specification:
\series default
 a request of a reservation, from the user, is handled correctly.
\end_layout

\begin_layout Itemize

\series bold
Description/purpose:
\series default
 the user must be able to make a reservation and to take it back.
 Each action includes the elaboration of the request (handled by the Reservation
Controller modules) and the creation/usage of the appropriate objects correspond
ing to the Model.
 This integration test verifies the correctness of each sequence of operations
 when all the events concerning a reservation occurs.
\end_layout

\begin_layout Itemize

\series bold
Dependencies:
\series default
 NONE.
\end_layout

\begin_layout Standard
\align center
\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "60col%"
height "1pt"

\end_inset


\end_layout

\begin_layout Itemize

\series bold
ID:
\series default
 IS5T2.
\end_layout

\begin_layout Itemize

\series bold
Test Item(s):
\series default
 ReservationController -> NotificationManager.
\end_layout

\begin_layout Itemize

\series bold
Input specification:
\series default
 ReservationController modules, Reservation, User (from Model).
\end_layout

\begin_layout Itemize

\series bold
Output specification:
\series default
 a push notification is sent to the User, about the handled Reservation.
\end_layout

\begin_layout Itemize

\series bold
Description/purpose:
\series default
 when the sequence of operations about a Reservation (make, take back, and
 so on) ends, the user has to be notified and so the ReservationController
 and NotificationManager must communicate and interact correctly.
\end_layout

\begin_layout Itemize

\series bold
Dependencies:
\series default
 PushGateway stub.
\end_layout

\begin_layout Subsubsection
Test case IS6
\end_layout

\begin_layout Itemize

\series bold
ID:
\series default
 IS6T1.
\end_layout

\begin_layout Itemize

\series bold
Test Item(s):
\series default
 MonitoringController -> Model.
\end_layout

\begin_layout Itemize

\series bold
Input specification:
\series default
 MonitoringController modules, Monitoring, Car, User (from Model).
\end_layout

\begin_layout Itemize

\series bold
Output specification:
\series default
 a request of a monitoring, from the user, is handled correctly.
\end_layout

\begin_layout Itemize

\series bold
Description/purpose:
\series default
 the user must be able to make a monitoring request (or more) and to take
 it back.
 Each action includes the elaboration of the request (handled by the MonitoringC
ontroller modules) and the creation/usage of the appropriate objects correspondi
ng to the Model.
 This integration test verifies the correctness of each sequence of operations
 when all the events concerning a reservation occurs.
\end_layout

\begin_layout Itemize

\series bold
Dependencies:
\series default
 NONE.
\end_layout

\begin_layout Standard
\align center
\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "60col%"
height "1pt"

\end_inset


\end_layout

\begin_layout Itemize

\series bold
ID:
\series default
 IS6T2.
\end_layout

\begin_layout Itemize

\series bold
Test Item(s):
\series default
 MonitoringController -> NotificationManager.
\end_layout

\begin_layout Itemize

\series bold
Input specification:
\series default
 MonitoringController modules, Monitoring, User (from Model).
\end_layout

\begin_layout Itemize

\series bold
Output specification:
\series default
 a push notification is sent to the User, about the handled Monitoring.
\end_layout

\begin_layout Itemize

\series bold
Description/purpose:
\series default
 when the sequence of operations about a Monitoring (make, take back, check
 and so on) ends, the user has to be notified and so the MonitoringController
 and NotificationManager must communicate and interact correctly.
\end_layout

\begin_layout Itemize

\series bold
Dependencies:
\series default
 PushGateway stub.
\end_layout

\begin_layout Subsubsection
Test case IS7
\end_layout

\begin_layout Itemize

\series bold
ID:
\series default
 IS7T1.
\end_layout

\begin_layout Itemize

\series bold
Test Item(s):
\series default
 RideController -> Model.
\end_layout

\begin_layout Itemize

\series bold
Input specification:
\series default
 RideController modules, Ride, User (from Model).
\end_layout

\begin_layout Itemize

\series bold
Output specification:
\series default
 a ride is handled correctly.
\end_layout

\begin_layout Itemize

\series bold
Description/purpose:
\series default
 when the user accesses the car and turns on the engine, the ride starts.
 The server is constantly informed about the ride data, such as location,
 cost, duration, fee, and so on.
 The ReservationController has to elaborate them and integrate all of this
 information with the Model objects.
 
\end_layout

\begin_layout Itemize

\series bold
Dependencies:
\series default
 NONE.
\end_layout

\begin_layout Standard
\align center
\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "60col%"
height "1pt"

\end_inset


\end_layout

\begin_layout Itemize

\series bold
ID:
\series default
 IS7T2.
\end_layout

\begin_layout Itemize

\series bold
Test Item(s):
\series default
 RideController -> NotificationManager.
\end_layout

\begin_layout Itemize

\series bold
Input specification:
\series default
 RideController modules, Ride, User (from Model).
\end_layout

\begin_layout Itemize

\series bold
Output specification:
\series default
 a push notification is sent to the User, about the handled Reservation.
\end_layout

\begin_layout Itemize

\series bold
Description/purpose:
\series default
 when the sequence of operations about a Ride (begin, check state, end)
 ends, the user has to be notified and so the RideController and NotificationMan
ager must communicate and interact correctly.
\end_layout

\begin_layout Itemize

\series bold
Dependencies:
\series default
 PushGateway stub.
\end_layout

\begin_layout Subsubsection
Test case IS8
\end_layout

\begin_layout Itemize

\series bold
ID:
\series default
 IS8T1.
\end_layout

\begin_layout Itemize

\series bold
Test Item(s):
\series default
 ConnectionHandler -> ReservationController.
\end_layout

\begin_layout Itemize

\series bold
Input specification:
\series default
 Method triggers (reservation concerning messages).
\end_layout

\begin_layout Itemize

\series bold
Output specification:
\series default
 the incoming message is correctly sorted into the ReservationController.
\end_layout

\begin_layout Itemize

\series bold
Description/purpose:
\series default
 Among all the incoming messages (both from the car and from the user) concernin
g a reservation have to be handled by the respective controller, that is
 the ReservationController.
\end_layout

\begin_layout Itemize

\series bold
Dependencies:
\series default
 NONE.
\end_layout

\begin_layout Standard
\align center
\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "60col%"
height "1pt"

\end_inset


\end_layout

\begin_layout Itemize

\series bold
ID:
\series default
 IS8T2.
\end_layout

\begin_layout Itemize

\series bold
Test Item(s):
\series default
 ConnectionHandler -> MonitoringController.
\end_layout

\begin_layout Itemize

\series bold
Input specification:
\series default
 Method triggers (monitoring concerning messages).
\end_layout

\begin_layout Itemize

\series bold
Output specification:
\series default
 the incoming message is correctly sorted into the MonitoringController.
\end_layout

\begin_layout Itemize

\series bold
Description/purpose:
\series default
 Among all the incoming messages (both from the car and from the user) concernin
g a monitoring have to be handled by the respective controller, that is
 the Monitoring.
\end_layout

\begin_layout Itemize

\series bold
Dependencies:
\series default
 NONE.
\end_layout

\begin_layout Standard
\align center
\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "60col%"
height "1pt"

\end_inset


\end_layout

\begin_layout Itemize

\series bold
ID:
\series default
 IS8T3.
\end_layout

\begin_layout Itemize

\series bold
Test Item(s):
\series default
 ConnectionHandler -> RideController.
\end_layout

\begin_layout Itemize

\series bold
Input specification:
\series default
 Method triggers (ride concerning messages).
\end_layout

\begin_layout Itemize

\series bold
Output specification:
\series default
 the incoming message is correctly sorted into the RideController.
\end_layout

\begin_layout Itemize

\series bold
Description/purpose:
\series default
 Among all the incoming messages (both from the car and from the user) concernin
g a ride have to be handled by the respective controller, that is the RideContro
ller.
\end_layout

\begin_layout Itemize

\series bold
Dependencies:
\series default
 NONE.
\end_layout

\begin_layout Standard
\align center
\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "60col%"
height "1pt"

\end_inset


\end_layout

\begin_layout Itemize

\series bold
ID:
\series default
 IS8T4.
\end_layout

\begin_layout Itemize

\series bold
Test Item(s):
\series default
 ConnectionHandler -> LoginController.
\end_layout

\begin_layout Itemize

\series bold
Input specification:
\series default
 Method triggers (login and registration concerning messages).
\end_layout

\begin_layout Itemize

\series bold
Output specification:
\series default
 the incoming message is correctly sorted into the LoginController.
\end_layout

\begin_layout Itemize

\series bold
Description/purpose:
\series default
 Among all the incoming messages (both from the car and from the user) concernin
g a login or a registration have to be handled by the respective controller,
 that is the LoginController.
\end_layout

\begin_layout Itemize

\series bold
Dependencies:
\series default
 NONE.
\end_layout

\begin_layout Subsection
Car integration test cases
\end_layout

\begin_layout Subsubsection
Test case IC1
\end_layout

\begin_layout Itemize

\series bold
ID:
\series default
 IC1T1.
\end_layout

\begin_layout Itemize

\series bold
Test Item(s):
\series default
 CarApplication -> CarSensorSystem (software)
\end_layout

\begin_layout Itemize

\series bold
Input specification:
\series default
 CarSensorSystem data.
\end_layout

\begin_layout Itemize

\series bold
Output specification:
\series default
 all the car data and signals are correctly elaborated.
\end_layout

\begin_layout Itemize

\series bold
Description/purpose:
\series default
 before the integration with the rest of the subsystems, it is necessary
 to ensure that the car application works correctly, grasping the car electronic
s data and elaborating it.
\end_layout

\begin_layout Itemize

\series bold
Dependencies:
\series default
 NONE.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Tools and Test Equipment Required
\end_layout

\begin_layout Standard
As described in the Design Document, the PowerEnJoy application is purely
 Java-based, so it is appropriate to use the numerous tools offered for
 testing java enterprise applications, including jUnit (for unit-testing)
 or Arquillan (for integration and functional testing).
 
\begin_inset Newline newline
\end_inset

When testing, especially in the early phases (and so mostly during the unit-test
ing), dummy objects will be created to represent real situations.
 However, as stated in section 2.3, those fakes should be created with a
 certain 
\begin_inset Quotes eld
\end_inset

logic
\begin_inset Quotes erd
\end_inset

 so that each fragment can be combined to form the real abstraction.
 As example, consider the class Reservation: in different unit tests it
 will be needed, but only partially, providing just some methods; combining
 all of its 
\begin_inset Quotes eld
\end_inset

versions
\begin_inset Quotes erd
\end_inset

 we may obtain a good result of the class, even almost complete.
\end_layout

\begin_layout Subsection
Automatic tests
\end_layout

\begin_layout Standard
Different tools can be used to achieve automatic, for both integration and
 unit, tests.
\end_layout

\begin_layout Itemize

\series bold
EvoSuite
\series default
: tool that automatically generates test cases with assertions for classes
 written in Java code.
 EvoSuite applies a novel hybrid approach that generates and optimizes whole
 test suites towards satisfying a coverage criterion.
 For the produced test suites, EvoSuite suggests possible oracles by adding
 small and effective sets of assertions that concisely summarize the current
 behavior.
\end_layout

\begin_layout Itemize

\series bold
JUnitEE
\series default
: is an extension of JUnit, which runs directly in the same application
 server as the project.
 JUnitEE provides three Servlets, which call the regular JUnit test cases.
\end_layout

\begin_layout Itemize

\series bold
Mock objects
\series default
: are mostly used for Unit Testing.
 They help in testing the interactions between the objects in an application.
 The one that will be used are JMock and Mockito.
\end_layout

\begin_layout Itemize

\series bold
Arquillian
\series default
: very powerful tool for Integration and Functional testing of Java middleware.
 It is most frequently used with the build tool Maven and on top of Unit
 Testing framework such as JUnit and TestNG.
 It frees the tester from creating Mock objects.
 Arquillian can be used to test JSF, EJB, Servlets and other Java classes.
\end_layout

\begin_layout Itemize

\series bold
SOASTA TouchTest™
\series default
: it delivers complete functional test automation for continuous multi-touch,
 gesture-based mobile applications.
 Mobile devices are controlled through a lightweight software agent, SOASTA
 TouchTest Agent.
\end_layout

\begin_layout Standard
Following two JUnit4 tests are presented, related to the possible implementation
 of algorithms presented in the Design Document, section 3.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename TestSamples/MonitoringAlgoTest.png
	lyxscale 20
	scale 60

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Monitoring algorithm class test
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename TestSamples/RideCostAlgoTest.png
	lyxscale 20
	scale 60

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Ride cost algorithm class test
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Manual tests
\end_layout

\begin_layout Standard
The whole application will be tested manually, to find possible way of improveme
nt or faults.
 One way to accomplish that is relying on the user experiences, which serves
 both to find design faults or dissatisfaction with the requirements of
 the software (as shown in the sample of figure 22, subsection 4.2 of the
 Design Document).
 Moreover technical aspects have to be tested, both in the user's device
 and in the cars (such as the piece of software that retrieves the data
 of the car or the position of a device).
\end_layout

\begin_layout Subsection
Performance tests
\end_layout

\begin_layout Standard
To have a performance test we will use Apache JMeter.
 This tool may be used to test performance both on static and dynamic resources,
 to simulate a heavy load on a server, group of servers, network or object
 to test its strength or to analyze overall performance under different
 load types.
\begin_inset Newline newline
\end_inset

We will perform a huge amount of requests of the same type and uniformly
 distributed (heavy load on reservation requests but also high amount of
 data exchange from the devices).
\begin_inset Newline newline
\end_inset

Moreover, some objects will be forced to endure extreme work, such as the
 logic components (great number of simultaneous algorithms invoked and such).
\begin_inset Newline newline
\end_inset

Important factors that will be analyzed will be response time for each request,
 maximum load and response behavior to peaks of work surrounded by periods
 of stasis (this represents a more real-world representation, because the
 service will be likely to be used more during certain periods of the day,
 like during the midday or evening work pause).
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Program stubs and Test data required
\end_layout

\begin_layout Subsection
Stubs
\end_layout

\begin_layout Standard
Since a bottom-up like approach has been followed, there are just a few
 stubs required when having the integration tests.
 
\end_layout

\begin_layout Subsubsection
GMSGateway
\end_layout

\begin_layout Paragraph
Usages
\end_layout

\begin_layout Itemize
IS1T1
\end_layout

\begin_layout Itemize
IS3T1
\end_layout

\begin_layout Paragraph
Description
\end_layout

\begin_layout Standard
The GMSGateway stub allows to test the SMS and mail sending functionality,
 emulating the external gateway.
 One of the main advantages is that there is no real usage of the external
 service (that is usually offered by an external provider, hence it has
 a money cost) and there is no need to test network features (it just needs
 to emulate the sending of stuff, not to do it for real).
\end_layout

\begin_layout Subsubsection
PushGateway
\end_layout

\begin_layout Paragraph
Usages
\end_layout

\begin_layout Itemize
IS1T2
\end_layout

\begin_layout Itemize
IS3T1
\end_layout

\begin_layout Itemize
IS5T2
\end_layout

\begin_layout Itemize
IS6T2
\end_layout

\begin_layout Itemize
IS7T2
\end_layout

\begin_layout Paragraph
Description
\end_layout

\begin_layout Standard
The PushGateway stub allows to test the push notification functionality,
 emulating the external gateway.
 As for the GMSGateway stub, it provides a way to use the push service without
 paying and no network features are needed.
\end_layout

\begin_layout Subsubsection
Database
\end_layout

\begin_layout Paragraph
Usages
\end_layout

\begin_layout Itemize
IS4T1
\end_layout

\begin_layout Paragraph
Description
\end_layout

\begin_layout Standard
Even before the subsystem integration and tests, during the Server components
 tests there is a need to simulate a real container for data, concerning
 the registration of a user.
 However integrating immediately the DB would be a waste of time and a complex
 procedure because it is not necessary to use all of its functions.
 Hence, a fictional version will be created to just receive registration
 requests and store small amount of data, mostly user concerning.
 
\end_layout

\begin_layout Subsection
Data needed for the tests
\end_layout

\begin_layout Standard
As it can be seen in the samples provided in subsection 4.1, a large number
 of fake objects (and consequently fake data) has to be inserted in the
 database and recreated in the model, to accomplish effective tests.
\begin_inset Newline newline
\end_inset

Various java libraries fills objects with dummy data (such as DummyCreator)
 and Arquillian provides a way to easily populates the database with such
 objects, used for testing.
\end_layout

\begin_layout Subsection
Critical data tests
\end_layout

\begin_layout Standard
As it was described in the section dedicated to the performance tests, some
 situation may require particular fake data clusters, such as:
\end_layout

\begin_layout Itemize
High number of cars sharing one or more features (position almost equal,
 same charge, same conditions).
\end_layout

\begin_layout Itemize
High number of users making the same reservation or monitoring request.
\end_layout

\begin_layout Itemize
Missing data when doing an operation (what if somehow, a user can make a
 reservation over an already occupied car?).
\end_layout

\begin_layout Itemize
Incomplete data.
\end_layout

\begin_layout Itemize
No categories (no users, no reservations, no monitoring, no rides, no accidents
 and so on).
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Document further information
\end_layout

\begin_layout Subsection
References
\end_layout

\begin_layout Itemize
RASD_4.7, before version 4.7
\end_layout

\begin_layout Itemize
DD_3.2, before version 3.2
\end_layout

\begin_layout Itemize
Assignments AA 2016-2017.pdf
\end_layout

\begin_layout Itemize
testing.pdf
\end_layout

\begin_layout Itemize
TP1.1.pdf
\end_layout

\begin_layout Itemize
Integration Test Plan Example.pdf
\end_layout

\begin_layout Itemize
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://www.softwaretestinghelp.com/java-testing-tools/
\end_layout

\end_inset

, describing some of the most well known automated testing tools for java
 based applications
\end_layout

\begin_layout Itemize
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://jmeter.apache.org
\end_layout

\end_inset

, describing the tool for performance testing
\end_layout

\begin_layout Itemize
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://arquillian.org
\end_layout

\end_inset

, describing the most used tool for Integration and Functional testing of
 Java middleware
\end_layout

\begin_layout Subsection
Used tools
\end_layout

\begin_layout Standard
In creating the ITPD document, the following tools have been used:
\end_layout

\begin_layout Itemize
Github, for version controller
\end_layout

\begin_layout Itemize
LyX, to write the document and converting in .pdf format
\end_layout

\begin_layout Itemize
Hunspell, for the spell check of the document
\end_layout

\begin_layout Itemize
Atom, for the project markdown
\end_layout

\begin_layout Subsection
ChangeLog
\end_layout

\begin_layout Itemize
[21/12/2016] [
\series bold
Version 0.1
\series default
] :: Given a structure to the document.
\end_layout

\begin_layout Itemize
[24-28/12/2016] [
\series bold
Version 1.0
\series default
] :: Added all the sections of the document.
\end_layout

\begin_layout Subsection
Hours of work
\end_layout

\begin_layout Subsubsection*
Matteo Frosi
\end_layout

\begin_layout Standard
[21-28/12/2016]: 14.00 hours (spent writing the whole document).
\end_layout

\begin_layout Subsubsection*

\series bold
Luca Cost
\series default
a
\end_layout

\end_body
\end_document
